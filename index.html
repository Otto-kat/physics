<!-- 氢原子电子云可视化 -->
<div class="card" style="max-width:900px;">
    <h2>氢原子电子云可视化（Hydrogen Electron Cloud）</h2>
    <p class="small">展示 1s 轨道概率密度分布。可拖拽旋转观察三维结构。</p>
    <div id="cloud3d" style="width:100%;height:400px;border-radius:12px;overflow:hidden;"></div>
    <canvas id="cloud2d" width="400" height="400" style="display:block;margin:12px auto;border-radius:12px;"></canvas>
</div>

<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ========== 3D电子云 ==========
    const container = document.getElementById('cloud3d');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, container.clientWidth / 400, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, 400);
    container.appendChild(renderer.domElement);

    camera.position.z = 3;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const geometry = new THREE.BufferGeometry();
    const points = [];
    const colors = [];

    // 模拟氢原子1s轨道的电子云概率密度分布
    for (let i = 0; i < 8000; i++) {
        const r = Math.random() * 2;
        const theta = Math.acos(2 * Math.random() - 1);
        const phi = Math.random() * 2 * Math.PI;

        const density = Math.exp(-2 * r); // 概率密度衰减
        if (Math.random() < density) {
            const x = r * Math.sin(theta) * Math.cos(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(theta);
            points.push(x, y, z);

            const c = new THREE.Color().setHSL(0.6 - 0.3 * r / 2, 1.0, 0.5);
            colors.push(c.r, c.g, c.b);
        }
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const material = new THREE.PointsMaterial({ size: 0.03, vertexColors: true });
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    const light = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(light);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        renderer.setSize(container.clientWidth, 400);
        camera.aspect = container.clientWidth / 400;
        camera.updateProjectionMatrix();
    });

    // ========== 2D 截面 ==========
    const canvas = document.getElementById('cloud2d');
    const ctx = canvas.getContext('2d');
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    const img = ctx.createImageData(canvas.width, canvas.height);
    for (let x = -cx; x < cx; x++) {
        for (let y = -cy; y < cy; y++) {
            const r = Math.sqrt(x * x + y * y) / 80;
            const prob = Math.exp(-2 * r) ** 2; // 概率密度平方
            const intensity = Math.min(255, Math.floor(255 * prob * 6));
            const idx = ((y + cy) * canvas.width + (x + cx)) * 4;
            img.data[idx + 0] = 60;
            img.data[idx + 1] = 160;
            img.data[idx + 2] = 255;
            img.data[idx + 3] = intensity;
        }
    }
    ctx.putImageData(img, 0, 0);
</script>

